var crco=function(t){"use strict";const i=2*Math.PI,n=(t,i,n)=>Math.max(Math.min(n,t),i),e=(t,i,n,e,s)=>({x:Math.cos(s)*(t-n)-Math.sin(s)*(i-e)+n,y:Math.sin(s)*(t-n)+Math.cos(s)*(i-e)+e}),s=t=>new Promise((i,n)=>{const e=new XMLHttpRequest;e.responseType="arraybuffer",e.addEventListener("load",()=>{200===e.status&&i(e.response)}),e.addEventListener("error",t=>{n(t)}),e.open("GET",t,!0),e.send()});return t.CanvasCoordinates=class{constructor(t={}){if(void 0===t.baseHeight&&void 0===t.canvas||void 0===t.baseWidth&&void 0===t.canvas)throw new Error("Invalid options. A canvas element must be supplied if baseHeight or baseWidth are not defined.");Object.assign(this,{nxRange:[-1,1],nyRange:[-1,1],padding:0,paddingX:0,paddingY:0,xOffset:0,yOffset:0,canvas:null,clamp:!1,baseHeight:null,baseWidth:null,orientationY:"down",...t}),this.width=this.baseWidth||this.canvas.width,this.height=this.baseHeight||this.canvas.height}nx(t,i={}){let e;return this.clamp&&(t=n(t,this.nxRange[0],this.nxRange[1])),e="number"==typeof i.padding?i.padding*this.width:(this.paddingX||this.padding)*this.width,e+this.xOffset+(t-this.nxRange[0])/(this.nxRange[1]-this.nxRange[0])*(this.width-2*e)}xn(t,i={}){let n;return n="number"==typeof i.padding?i.padding*this.width:(this.paddingX||this.padding)*this.width,(t-n-this.xOffset)/(this.width-2*n)}ny(t,i={}){let e;return this.clamp&&(t=n(t,this.nyRange[0],this.nyRange[1])),e="number"==typeof i.paddingY?i.paddingY*this.height:"number"==typeof i.padding?i.padding*this.width:"number"==typeof this.paddingY?this.paddingY*this.height:this.padding*this.width,"down"===this.orientationY?e+this.yOffset+(t-this.nyRange[0])/(this.nyRange[1]-this.nyRange[0])*(this.height-2*e):"up"===this.orientationY?this.height-e-this.yOffset-(t-this.nyRange[0])/(this.nyRange[1]-this.nyRange[0])*(this.height-2*e):void 0}yn(t,i={}){let n;return n="number"==typeof i.paddingY?i.paddingY*this.height:"number"==typeof i.padding?i.padding*this.width:"number"==typeof this.paddingY?this.paddingY*this.height:this.padding*this.width,"down"===this.orientationY?(t-n-this.yOffset)/(this.height-2*n):"up"===this.orientationY?(this.height-t-n-this.yOffset)/(this.height-2*n):void 0}getWidth(){return this.nx(this.nxRange[1])-this.nx(this.nxRange[0])}getHeight(){return"down"===this.orientationY?this.ny(this.nyRange[1])-this.ny(this.nyRange[0]):"up"===this.orientationY?this.ny(this.nyRange[0])-this.ny(this.nyRange[1]):void 0}},t.Spread=class{constructor(t){const i={anchor:"spacing",border:void 0,bounds:[0,1],count:10,dimensions:1,distribution:t=>t};Object.assign(this,{...i,...t}),this.flatData=[],this.data=this.getData(this.count,this.bounds,this.dimensions)}getData(){const t=this.ndArray(this.getDimensionCounts()),i=(t,n,e)=>{const s=this.getBounds(n),a=this.getAnchor(n),h=this.getDistribution(n),r=(s[1]-s[0])/t.length;for(let o=0;o<t.length;o++){const d=[...e];let u;switch(a){case"spacing":u=h(s[0]+r*(o+.5),{d:n,i:o});break;case"endpoints":u=h(s[0]+r*o,{d:n,i:o});break;default:throw new Error("Anchor type not valid. Choose from (spacing, endpoints).")}d.push(u),n<this.dimensions?i(t[o],n+1,d):(void 0===this.border||this.border(...d))&&(t[o]=d,this.flatData.push(d))}};return i(t,1,[]),t}ndArray(t){if(t.length>0){const i=t[0],n=t.slice(1),e=new Array;for(let t=0;t<i;t++)e[t]=this.ndArray(n);return e}}getAnchor(t){if("number"==typeof t)return Array.isArray(this.anchor)?void 0!==this.anchor[t-1]?this.anchor[t-1]:void 0:this.anchor}getBounds(t){if("number"==typeof t)return Array.isArray(this.bounds[0])?void 0!==this.bounds[t-1]?this.bounds[t-1]:void 0:this.bounds}getCount(t){if("number"==typeof t)return Array.isArray(this.count)?void 0!==this.count[t-1]?this.count[t-1]:void 0:this.count}getDistribution(t){if("number"==typeof t)return Array.isArray(this.distribution)?void 0!==this.distribution[t-1]?this.distribution[t-1]:void 0:this.distribution}getDimensionCounts(){const t=[];for(let i=1;i<=this.dimensions;i++)t[i-1]=this.getCount(i);return t}},t.TAU=i,t.boundedCos=(t=1,i=-1,n=1,e=0,s=0,a=!1)=>h=>i+(n-i)*(.5+(a?-1:1)*Math.cos(-e+Math.PI*h/(t/2))/2)+s,t.boundedSin=(t=1,i=-1,n=1,e=0,s=0,a=!1)=>h=>i+(n-i)*(.5+(a?-1:1)*Math.sin(-e+Math.PI*h/(t/2))/2)+s,t.cartToPolar=(t,i)=>({r:Math.sqrt(t*t+i*i),theta:Math.atan2(i,t)}),t.clamp=n,t.createAudioPlayer=(t,i,n={})=>{const e=n.fade||!1,a=n.fadeLength||null,h=n.fadeType||"exponential",r=n.offlineRendering||!1,o=n.logLevel||"none";return new Promise((d,u)=>{s(i).then(i=>{t.decodeAudioData(i,(function(i){if(r){const s=n.renderLength||i.length,r=s/i.sampleRate,u=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(2,s,i.sampleRate);u.oncomplete=i=>{const{renderedBuffer:n}=i;"debug"===o&&console.log(n);const e=t.createBufferSource();e.buffer=n,d(e)};const g=u.createGain(),c=u.createBufferSource();c.buffer=i,c.connect(g),g.connect(u.destination),e&&(g.gain.setValueAtTime(.001,u.currentTime),g.gain.setValueAtTime(1,u.currentTime+r-a),"exponential"===h?(g.gain.exponentialRampToValueAtTime(1,u.currentTime+a),g.gain.exponentialRampToValueAtTime(.001,u.currentTime+r)):"linear"===h&&(g.gain.linearRampToValueAtTime(1,u.currentTime+a),g.gain.linearRampToValueAtTime(.001,u.currentTime+r))),c.start(),u.startRendering()}else{const n=t.createBufferSource();n.buffer=i,d(n)}}),t=>{"debug"===o&&console.error(t),u(t)})}).catch(t=>{"debug"===o&&console.error(t),u(t)})})},t.drawLine2D=(t,i,n)=>{t.beginPath();for(let e=0;e<=i;e++){const s=n(e/i);0===e?t.moveTo(s[0],s[1]):t.lineTo(s[0],s[1])}t.stroke()},t.equilateralTriangle=(t,i,n,s)=>{const a=[],h=n*Math.sqrt(3)/2;return a.push(e(t,i-2*h/3,t,i,s)),a.push(e(t+n/2,i*(h/3),t,i,s)),a.push(e(t-n/2,i*(h/3),t,i,s)),a},t.gaussianRand=(t=6)=>{let i=0;for(let n=0;n<t;n+=1)i+=Math.random();return i/t},t.isocelesTriangle=(t,i,n,s,a)=>{const h=[],r=Math.sqrt(s*s/4-n*n);return h.push(e(t,i-2*r/3,t,i,a)),h.push(e(t+s/2,i*(r/3),t,i,a)),h.push(e(t-s/2,i*(r/3),t,i,a)),h},t.lerp=(t,i,n)=>t*(1-n)+i*n,t.linToLog=t=>{let i=Math.log(1/t)/(1-t);return{a:t/Math.exp(i*t),b:i}},t.loadArrayBuffer=s,t.normalize=(t,i,n,e)=>{return{x:e*t/Math.sqrt(t*t+i*i+n*n),y:e*i/Math.sqrt(t*t+i*i+n*n),z:e*n/Math.sqrt(t*t+i*i+n*n)}},t.polarToCart=(t,i)=>({x:t*Math.cos(i),y:t*Math.sin(i)}),t.regularPolygon=(t,i=1,n=0,e=0,s=!0,a=!1,h=!1)=>{const r=s?t+1:t,o=h?2:3,d=new Float32Array(r*o);for(let s=0;s<r;s++)h?(d[s*o]=n+i*Math.cos(2*s*Math.PI/t),d[s*o+1]=e+i*Math.sin(2*s*Math.PI/t)):(d[s*o]=n+i*Math.cos(2*s*Math.PI/t),d[s*o+1]=a?0:e+i*Math.sin(2*s*Math.PI/t),d[s*o+2]=a?e+i*Math.sin(2*s*Math.PI/t):0);return d},t.rotatePoint=e,t.solveExpEquation=(t,i,n,e)=>{const s=Math.pow(e/i,1/(n-t));return{a:i/Math.pow(s,t),b:s}},t.star=(t,i,n,e)=>{},t}({});
